import {DataGridEditingExample} from "../../components/examples/datagrid-editing-example";
import Preview from "../../components/Preview";
import {DataGridEditingOptimisticExample} from "../../components/examples/datagrid-editing-optimistic-example";
import {DataGridEditingValidationExample} from "../../components/examples/datagrid-editing-validation-example";

## Editing

### Requirements

- You need to have a `ToastProvider` at the root of your project. [Learn more](https://chalk-storybook.rahim.app/?path=/docs/components-overlays-toast--readme).

### Making a column editable

- `withEditing` is a helper that makes a column's cells editable.
- By default, only one row can be editable at a time. Users can edit all cells in a row simultaneously.
- The helper takes **zod** schema and a key as parameter in order to validate the entire row data when saving.
- You must provide an `onRowEdit` callback function prop where you will get access to the updated row data so that changes can be processed and saved. It is up to you how you handle the data.


```tsx showLineNumbers {32-37,50-52}
import React, { useCallback, useEffect, useMemo, useState } from "react"
import { createDataGridColumns, DataGrid } from "@/components/ui/datagrid"
import { createTypesafeFormSchema } from "@/components/ui/typesafe-form"
import { fetchFakeData, Product } from "@/components/examples/datagrid-fake-api"
import { TextInput } from "@/components/ui/text-input"

const schema = createTypesafeFormSchema(({ z }) => z.object({
    name: z.string().min(3),
}))

export function DataGridEditingExample() {

    const { data, isLoading, refetch } = useFakeQuery({
        ...queryOptions,
        keepPreviousData: true,
    })

    const { mutate, isMutating } = useFakeMutation({
        ...mutationOptions,
        onSuccess: data => {
            if (data) {
                refetch() // Refetch table data
            }
        },
    })

    const columns = useMemo(() => createDataGridColumns<Product>(({ withEditing }) => [
        {
            accessorKey: "name",
            header: "Name",
            meta: {
                ...withEditing({
                    zodType: schema.shape.name,
                    field: (ctx) => (
                        <TextInput {...ctx} onChange={e => ctx.onChange(e.target.value ?? "")} intent={"unstyled"}/>
                    ),
                }),
            }
        },
        ...rest
    ]), [])

    return (
        <DataGrid<Product>
            columns={columns}
            data={data}
            rowCount={data?.meta?.totalRowCount ?? 0}
            isLoading={isLoading}
            isDataMutating={isMutating}
            onRowEdit={event => {
                mutate(event.data)
            }}
        />
    )

}
```

<Preview contentClassName={"max-w-full"}>
    <DataGridEditingExample/>
</Preview>

#### withEditing

##### Type

The type will be passed down to the context.

```tsx /schema.shape.name/ /<string>/
const schema = createTypesafeFormSchema(({z}) => z.object({
    name: z.string(),
    ...
}))

// Column def

meta: {
    ...withEditing({
        zodType: schema.shape.name, // Define type from zod
        field: (ctx) => {
            console.log(ctx.value) // string
        },
    }),
}

meta: {
    ...withEditing<string>({ // Or define it from generics
        field: (ctx) => {
            console.log(ctx.value) // string
        },
    }),
}
```

##### Edit field component

```tsx
{
    accessorKey: "name",
    header: "Name",
    meta: {
        ...withEditing({
            zodType: schema.shape.name,
            field: (ctx, { rowErrors, row }) => {

                // Get field's error
                const error = rowErrors.find(n => n.key === "name" && n.rowId === row.id)

                return (
                    <TextInput
                        value={ctx.value}
                        onChange={e => ctx.onChange(e.target.value ?? "")}
                        ref={ctx.ref} // focus() is called when the user double-clicks a cell
                        intent={"unstyled"}
                    />
                )
            }
        }),
    },
}
```

- **context**
- `value`: Controlled value
- `onChange`: Value updater
- `ref`
- **options**
- `rowErrors`: Validation errors. Type: `Array<{ rowId: string, key: string, message: string }>`
- `rowId`: The row ID
- `key`: The column key
- `message`: The error message
- `table`
- `row`
- `cell`

### Validation

Validation is done using `zod` and is automatically handled by DataGrid when you provide `validationSchema`.

```tsx showLineNumbers {1-3,11,21}
const schema = createTypesafeFormSchema(({ z }) => z.object({
    name: z.string().min(3),
}))

const columns = useMemo(() => createDataGridColumns<Product>(({ withEditing }) => [
    {
        accessorKey: "name",
        header: "Name",
        meta: {
            ...withEditing({
                zodType: schema.shape.name,
                field: (ctx) => {},
            }),
        }
    },
    ...rest
]), [])

<DataGrid<T>
    {...props}
    validationSchema={schema}
/>
```

<Preview contentClassName={"max-w-full"}>
    <DataGridEditingValidationExample/>
</Preview>

### Events

#### onRowEdit

- `data`: The updated row data
- `originalData`: The original row data
- `row`: Row API. [See reference](https://tanstack.com/table/v8/docs/api/core/row#row-api).

```tsx
<DataGrid<T>
    {...props}
    onRowEdit={({ data, originalData, row }) => {
        // Handle update
    }}
/>
```


#### onRowValidationError

- `errors`: Zod errors from validation. Type: `ZodIssue[]`.
- `data`: The updated row data
- `originalData`: The original row data
- `row`: Row API. [See reference](https://tanstack.com/table/v8/docs/api/core/row#row-api).

```tsx
<DataGrid<T>
    {...props}
    onRowValidationError={({ errors, data, originalData, row }) => {
        // Handle errors
    }}
/>
```

### Optimistic updates

1. Set `enableOptimisticUpdates` to `true`
2. Provide a `optimisticUpdatePrimaryKey` that will be used by DataGrid to locate the row and perform the optimistic updates
3. Handle potential errors by refetching/refreshing the data in case of an internal server error
4. When optimistic updates are enabled, DataGrid will not display a loading state when `isDataMutating` is true

```tsx
<DataGrid<T>
    {...props}
    enableOptimisticUpdates
    optimisticUpdatePrimaryKey={"id"}
/>
```

<Preview contentClassName={"max-w-full"}>
    <DataGridEditingOptimisticExample/>
</Preview>

### Server-side validation

Server-side validation can be handled using `zod` schemas.

```tsx showLineNumbers {7-14,17,28,29}
const { data, isLoading, refetch } = useFakeQuery({ ...queryOptions })

const { mutate, isMutating } = useFakeMutation({ ...mutationOptions })

const [isValidating, setIsValidating] = useState(false) // Block events by tracking the validation status

const nameValidation = useRef(
    async (value: string) => {
        setIsValidating(true)
        const res = await getNameValidation(value) // Server-side validation
        setIsValidating(false)
        return res.isUnique
    }
)

const schema = createTypesafeFormSchema(({z}) => z.object({
    name: z.string().refine(value => nameValidation.current(value), { message: "Name already exists" }),
    price: z.number().min(3),
    category: z.string().nullable(),
    availability: z.string(),
    visible: z.boolean(),
}))

return (
    <DataGrid<Product>
        {...props}
        isLoading={isLoading}
        isDataMutating={isMutating || isValidating}
        validationSchema={schema}
    />
)
```
